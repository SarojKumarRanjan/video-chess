import { useGameStore } from '../store/gameStore'; // Access state for streams, etc.
import { useUserStore } from '../store/userStore'; // Access user info
import { MessagePayload } from '../types'; // Shared types

let peerConnection: RTCPeerConnection | null = null;
let localStream: MediaStream | null = null; // Keep track of local stream locally too

// --- Configuration ---
// For local development, STUN server is usually enough.
// For production apps crossing NATs/firewalls, TURN servers are often required.
// You can get free STUN servers (e.g., from Google) or host your own.
const peerConnectionConfig: RTCConfiguration = {
    iceServers: [
        { urls: 'stun:stun.l.google.com:19302' },
        { urls: 'stun:stun1.l.google.com:19302' },
        // Add TURN server config here if needed:
        // {
        //   urls: 'turn:your.turn.server.com:3478',
        //   username: 'your_username',
        //   credential: 'your_password'
        // }
    ]
};

// Type for the function that sends WS messages
type SendMessageFunction = (message: MessagePayload) => void;


// --- Core Functions ---

// Initialize or get the existing Peer Connection
export function initializePeerConnection(sendMessage: SendMessageFunction): RTCPeerConnection | null {
     if (peerConnection) {
         console.warn("Peer connection already exists. Re-using.");
         return peerConnection;
     }
    console.log("Initializing Peer Connection...");
    try {
        peerConnection = new RTCPeerConnection(peerConnectionConfig);

        // Handle ICE candidates generated by the browser
        peerConnection.onicecandidate = (event) => {
            if (event.candidate) {
                console.log("Generated ICE candidate:", event.candidate.type, event.candidate.sdpMLineIndex);
                 const currentGameId = useGameStore.getState().currentGame?.id;
                 const userId = useUserStore.getState().user?.id;
                 if (currentGameId && userId) {
                    // Send the candidate to the remote peer via WebSocket signaling server
                    sendMessage({
                        type: 'VIDEO_ICE',
                        payload: {
                            gameId: currentGameId,
                            userId: userId,
                            candidate: event.candidate.toJSON() // Send serializable candidate object
                        }
                    });
                } else {
                     console.error("Cannot send ICE candidate: Missing gameId or userId.");
                }
            } else {
                console.log("All ICE candidates have been sent.");
            }
        };

        // Handle incoming remote video stream
        peerConnection.ontrack = (event) => {
            console.log("Received remote track:", event.track.kind);
             if (event.streams && event.streams[0]) {
                 console.log("Attaching remote stream to store.");
                 useGameStore.getState().setRemoteStream(event.streams[0]);
             } else {
                 // Fallback for older browsers?
                 const newStream = new MediaStream();
                 newStream.addTrack(event.track);
                 useGameStore.getState().setRemoteStream(newStream);
             }
        };

        // Handle connection state changes (for debugging/UI feedback)
        peerConnection.oniceconnectionstatechange = () => {
            console.log("ICE Connection State Change:", peerConnection?.iceConnectionState);
             if (peerConnection?.iceConnectionState === 'failed' ||
                 peerConnection?.iceConnectionState === 'disconnected' ||
                 peerConnection?.iceConnectionState === 'closed') {
                  console.error("WebRTC connection failed or closed.");
                  // Optionally try ICE restart or close the connection
                  // closePeerConnection();
                  // useGameStore.getState().setVideoCallActive(false);
             }
             if (peerConnection?.iceConnectionState === 'connected') {
                 console.log("WebRTC connection established!");
             }
        };

         peerConnection.onconnectionstatechange = () => {
             console.log("Connection State Change:", peerConnection?.connectionState);
         };

        console.log("Peer Connection Initialized.");
        return peerConnection;

    } catch (error) {
        console.error("Error creating Peer Connection:", error);
        peerConnection = null;
        return null;
    }
}

// Get User Media (Camera/Microphone)
export async function getLocalStream(): Promise<MediaStream | null> {
    console.log("Requesting local media stream...");
    try {
        const stream = await navigator.mediaDevices.getUserMedia({
            video: true,
            audio: true
        });
        console.log("Local media stream obtained.");
        localStream = stream; // Store locally
        useGameStore.getState().setLocalStream(stream); // Update zustand store
        return stream;
    } catch (error) {
        console.error("Error accessing media devices:", error);
        alert("Could not access camera/microphone. Please check permissions.");
        localStream = null;
        useGameStore.getState().setLocalStream(null);
        return null;
    }
}

// Create and send Offer
export async function createOffer(pc: RTCPeerConnection, sendMessage: SendMessageFunction) {
    console.log("Creating WebRTC offer...");
    try {
        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);
        console.log("Local description (offer) set.");

        const currentGameId = useGameStore.getState().currentGame?.id;
        const userId = useUserStore.getState().user?.id;

        if (currentGameId && userId && pc.localDescription) {
            console.log("Sending offer to peer...");
            sendMessage({
                type: 'VIDEO_OFFER',
                payload: {
                    gameId: currentGameId,
                    userId: userId,
                    offer: pc.localDescription.toJSON() // Send serializable offer object
                }
            });
        } else {
             console.error("Cannot send offer: Missing gameId, userId, or localDescription.");
        }
    } catch (error) {
        console.error("Error creating or sending offer:", error);
    }
}

// Handle Incoming WebRTC Signaling Messages
export async function handleIncomingWebRTCMessage(
    message: MessagePayload,
    sendMessage: SendMessageFunction // Function to send messages back
) {
    const pc = initializePeerConnection(sendMessage); // Ensure PC is initialized
    if (!pc) {
        console.error("Cannot handle WebRTC message: PeerConnection not available.");
        return;
    }
     const userId = useUserStore.getState().user?.id;
     const currentGameId = useGameStore.getState().currentGame?.id;

    try {
        switch (message.type) {
            case 'VIDEO_OFFER':
                 if (message.payload.userId === userId) return; // Ignore own offer
                console.log("Received offer from peer:", message.payload.userId);
                 // Ensure local stream is ready before setting remote description and creating answer
                 if (!localStream) {
                    localStream =   await getLocalStream(); // Get local stream first
                     if (!localStream) {
                          console.error("Cannot handle offer: Failed to get local stream.");
                          // Maybe send an error back to the peer?
                          return;
                     }
                     // Add tracks *before* setting remote description and creating answer
                     localStream.getTracks().forEach(track => {
                         // Avoid adding duplicate tracks if connection restarts
                         if (!pc.getSenders().find(sender => sender.track === track)) {
                             pc.addTrack(track, localStream!);
                             console.log(`Added local ${track.kind} track to peer connection.`);
                         }
                     });
                 }


                await pc.setRemoteDescription(new RTCSessionDescription(message.payload.offer));
                console.log("Remote description (offer) set.");

                // Create Answer
                console.log("Creating answer...");
                const answer = await pc.createAnswer();
                await pc.setLocalDescription(answer);
                console.log("Local description (answer) set.");

                // Send Answer back
                if (currentGameId && userId && pc.localDescription) {
                     console.log("Sending answer to peer...");
                    sendMessage({
                        type: 'VIDEO_ANSWER',
                        payload: {
                            gameId: currentGameId,
                            userId: userId,
                            answer: pc.localDescription.toJSON()
                        }
                    });
                } else {
                    console.error("Cannot send answer: Missing gameId, userId, or localDescription.");
                }
                useGameStore.getState().setVideoCallActive(true); // Mark call as active
                break;

            case 'VIDEO_ANSWER':
                if (message.payload.userId === userId) return; // Ignore own answer
                console.log("Received answer from peer:", message.payload.userId);
                if (pc.signalingState === 'have-local-offer') { // Only set answer if we sent an offer
                    await pc.setRemoteDescription(new RTCSessionDescription(message.payload.answer));
                    console.log("Remote description (answer) set.");
                     useGameStore.getState().setVideoCallActive(true); // Mark call as active
                } else {
                     console.warn("Received answer but not in expected state:", pc.signalingState);
                }
                break;

            case 'VIDEO_ICE':
                 if (message.payload.userId === userId) return; // Ignore own candidates
                // console.log("Received ICE candidate from peer:", message.payload.userId); // Noisy
                try {
                    await pc.addIceCandidate(new RTCIceCandidate(message.payload.candidate));
                    // console.log("Added received ICE candidate."); // Noisy
                } catch (error) {
                    console.error("Error adding received ICE candidate:", error);
                }
                break;

            default:
                // Ignore other message types handled elsewhere
                break;
        }
    } catch (error) {
        console.error(`Error handling incoming WebRTC message (${message.type}):`, error);
    }
}


// Close Peer Connection and cleanup
export function closePeerConnection() {
    console.log("Closing Peer Connection and cleaning up streams...");
    if (peerConnection) {
        // Stop all tracks on the local stream stored in the game store
        const storeStream = useGameStore.getState().localStream;
        storeStream?.getTracks().forEach(track => track.stop());
        console.log("Stopped local stream tracks.");

        // Also stop the locally tracked stream variable
         localStream?.getTracks().forEach(track => track.stop());
         localStream = null;

        // Close the peer connection
        peerConnection.close();
        peerConnection = null;
        console.log("Peer Connection closed.");
    } else {
        console.log("No active Peer Connection to close.");
    }
    // Reset streams in the store
    useGameStore.getState().setLocalStream(null);
    useGameStore.getState().setRemoteStream(null);
    useGameStore.getState().setVideoCallActive(false);
}